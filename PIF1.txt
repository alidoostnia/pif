//Synchronous PIF self stabilising algorithm for a tree with 4 processes
// Written by Mehran Alidoost Nia on February 04, 2017 

dtmc

const double r0=0.5;
const double r1=0.5;
const double r2=0.5;
const double r3=0.5;
const double q1=0.2;
const bool up2=false;
const bool up3=false;
const bool up0=true;

module process0

	x0 : bool ; //state variable
	l0 : [-1..3];  //id of process
	a0 : bool; //active
	p0 : bool; //privilege

	//token-2a for root
	[] (x0)&((x0=x1 & !up1)|(x0=x2 & !up2))  -> r0:(l0'=1)& (x0'=!x0)+q1:(l0'=2) & (x0'=!x0)+1-r0-q1:(l0'=-1) & (x0'=!x0);

	//token-4 and active
	[] (!x0)&(x0=x1 &!up1)&(x0=x2 &!up2) &a0 -> (p0'=true)&(l0'=-1) & (x0'=!x0);

	//token-4 and not active
	[] (!x0)&(x0=x1 &!up1)&(x0=x2 &!up2) &!a0 -> (l0'=-1) & (x0'=!x0);

endmodule

module process1

	x1 : bool ; //state variable
	l1 : [-1..3];  //id of process
	a1 : bool; //active
	p1 : bool; //privilege
	up1 : bool ; //up variable

	//[] (x0!=x1)&(!x1)&(!a1) -> (l1'=-1) & (up1'=true) & (x1'=!x1); //token1 and not active
	//[] (x0!=x1)&(!x1)&(a1) -> (l1'=1) & (up1'=false) & (x1'=!x1); //token1 and active
	[] (x0!=x1)&(!x1) -> r1: (l1'=-1) & (up1'=true) & (x1'=!x1)+ 1-r1: (l1'=1) & (up1'=false) & (x1'=!x1);

	[] (up1)&(x1)&(x1=x3  & l3!=-1 & up3=false )&(x0=x1) -> (l1'=3) & (up1'=false); //token-2a and parent x 
	[] (up1)&(x1)&( (x1=x3  & l3=-1 & up3=false)) &(x0=x1) -> (up1'=false); //token-2b
	[] (x0!=x1)&(x1)&(l0=1)&(l1=1) -> (p1'=true)&(up1'=false) & (x1'=!x1);//token3 and id
	[] (x0!=x1)&(x1)&(l0=1)&((l1=3))-> (up1'=true) & (x1'=!x1); //token 3 and children
	[] (x0!=x1)&(x1)&((l0!=1)|((l1!=1)&(l1!=3)))-> (l1'=-1)&(up1'=false) & (x1'=!x1);
	[] (up1)&(!x1)&(x1=x3)&(x0=x1) -> (up1'=false) ; //token4

endmodule


module process2

	x2 : bool ; //state variable
	l2 : [-1..3];  //id of process
	a2 : bool; //active
	p2 : bool; //privilege

	//[] (x0!=x2)&(!x2)&(!a2) -> (l2'=-1) & (x2'=!x2); //token1 and not active
	//[] (x0!=x2)&(!x2)&(a2) -> (l2'=2) & (x2'=!x2); //token1 and active
	[] (x0!=x2)&(!x2)-> r2:(l2'=-1) & (x2'=!x2)+ 1-r2: (l2'=2) & (x2'=!x2);
	[] (x0!=x2)&(x2)&(l0=2)&(l2=2) -> (p2'=true)&(x2'=!x2);//token3 and id
	[] (x0!=x2)&(x2)& ((l0!=2)|(l2!=2)) -> (x2'=!x2);//token3 and not id


endmodule


module process3

	x3 : bool ; //state variable
	l3 : [-1..3];  //id of process
	a3 : bool; //active
	p3 : bool; //privilege

	//[] (x1!=x3)&(!x3)&(!a3) -> (l3'=-1) & (x3'=!x3); //token1 and not active
	//[] (x1!=x3)&(!x3)&(a3) -> (l3'=3) & (x3'=!x3); //token1 and active
	[] (x1!=x3)&(!x3)-> r3:(l3'=-1) & (x3'=!x3)+ 1-r3: (l3'=3) & (x3'=!x3);
	[] (x1!=x3)&(x3)&(l1=3)&(l3=3) -> (p3'=true)&(x3'=!x3);//token3 and id
	[] (x1!=x3)&(x3)& ((l1!=3)|(l3!=3)) -> (x3'=!x3);//token3 and not id


endmodule




//test formula
formula f1=(up1&x1&l1=-1&a3);
formula f2=(!up1&x1&l0=1)|((!up1&x1&l0=1)&(x3&l1=3))|((!up1&x1&l1=-1&!a1)&(x3&l3=-1&!a3))|(x2&l2=-1&!a2);
formula f3=(x0)&((x0&l0=-1)|(x3&up3&l3=-1))&((x1&l0=1)|(x2&l0=2&x0)|(x3&l1=3&x1));
formula f4=(!x0)&((a1&!a3&l0=1)|(a3&l1=3&l0=1)|(a2&l0=2));
formula stability=f4|f3|f2|f1;



// rewards (to calculate expected number of steps)
rewards "steps"
  true : 1;
endrewards

init
   true
endinit

// label - stable configurations
label "stable" = stability;

